## #!/usr/bin/env python3

import csv
from pickle import TRUE
import sys
import pandas as pd
import argparse

csv.field_size_limit(sys.maxsize)


## Arguments/inputs ----

parser = argparse.ArgumentParser(add_help=TRUE)
parser.add_argument("--blastout", help="output from submit_mito_blast2.sh; format 6 csv table generated by blasting the assembly against the mitochondrial database")
args = parser.parse_args()


## Functions ----

def readfile(infile, dfname):
    # Open tabular format output from blast of scaffolds against NCBI mitochondrial db
    tabfile = []
    with open(infile,'r') as file:
        file = csv.reader(file, delimiter = '\t')
        for line in file: 
            tabfile.append(line)

    ## put in some sort of ... if sum alignment lengths < total scaff length, do not bother checking for coverage 
    dfname = pd.DataFrame(tabfile, columns = ['qseqid', 'sseqid', 'length', 'qstart', 'qend', 'evalue' , 'qlen', 'qcovs','qcovhsp'])
    return (dfname)

def calccov(df):
    highCovReportLines = []
    highCovScaffs = set()

    ## list of all the unique scaffolds named in the blast output 
    uniqScaffs = df.qseqid.unique()

    for uniqScaff in uniqScaffs:

        rows = df.loc[df['qseqid'] == uniqScaff] ## isolate rows with a particular scaffold name 

        uniqAccs = rows.sseqid.unique()

        totalScaffLength = (list(rows['qlen']))[0]

        for uniqAcc in uniqAccs:

            rowsAcc = rows.loc[rows['sseqid'] == uniqAcc]

            ## making a list of all the alignment start and end positions 
            starts = list(rowsAcc['qstart'].astype('int')) 
            ends = list(rowsAcc['qend'].astype('int'))

            startsEndsDf = pd.DataFrame(list(zip(starts,ends)),
                                        columns =['starts','ends'])

            startsEndsDfSort = startsEndsDf.sort_values('starts')

            startsSort = list(startsEndsDfSort['starts'])
            endsSort = list(startsEndsDfSort['ends'])

            coverage = 0
            currentpos = 0
            for i in range(len(startsSort)):
                alignLength = endsSort[i] - startsSort[i]
                if startsSort[i] > currentpos:
                    coverage += alignLength
                    currentpos = endsSort[i]
                elif (startsSort[i] < currentpos) and (endsSort[i] > currentpos):
                    coverage += (endsSort[i] - currentpos)
                    currentpos = endsSort[i]
        
            percentCov = (coverage/int(totalScaffLength))*100
            
            if percentCov > 95: 
                highCovReport = [uniqScaff,uniqAcc,totalScaffLength,coverage,percentCov]
                highCovReportLines.append(highCovReport)
                highCovScaffs.add(uniqScaff)

    return (highCovReportLines, highCovScaffs)
    

## Function testing ----

## Passing a small test tsv file through the readfile function, then isolating the 'qlen' value from the file row. 
## If the test value matches the expected qlen then the script continues, otherwise it exits with an error. 
testfile_path = "./test-data/test_input.tsv"

testdf = readfile(testfile_path, dfname = "testdef1")

actual_read = testdf.iloc[-1].loc['length']
expected_read = str(3459)

if actual_read != expected_read:
    print ("ERROR! line 22: tsv not read in successfully \nexiting parse_mito_blast.py")
    exit()
else:
    print ("Read in file test successful.")


## Passing the test file to the calcov function - if the first line is as expected then the script continues. Otherwise, it exits.
testcalccov = calccov(testdf)

testcovline = testcalccov[0][0]
truecovline =['SCAFFOLD_266', 'NC_007897.1', '33195', 33191, 99.98794999246876]

if testcovline != truecovline:
    print ("ERROR! line 35: cannot calculate scaffold-accession coverage \nexiting parse_mito_blast.py")
    exit ()
else:
    print ("Pairwise scaffold-accession alignment coverage successfully calculated.")


## Calculating coverage ----

blastdf = readfile(args.blastout, dfname = "blastdf")
highCovReportLines = calccov(blastdf)

## Writing the output to a csv report. 
highCovReports = (pd.DataFrame(highCovReportLines[0], columns=['Scaffold','Acc_number','Scaffold_len','Scaffold_align_cov','Perc_align_cov'])).sort_values('Perc_align_cov', ascending = False)
## just pass a file name for now - can rig something better later. 
highCovReports.to_csv("cov_report.tsv", sep="\t")

with open('mito_scaff_names.txt', 'w') as f:
    [f.write(scaff) for scaff in highCovReportLines[1]]
    f.close()
